{
  "api": {
    "prefix": "_api",
    "scope": "typescript",
    "description": "Template d'une route API (controller)",
    "body": [
      "import { NextRequest, NextResponse } from 'next/server'",
      "",
      "import { getSession } from '@/gateways/NextAuthAuthentificationGateway'",
      "import { isNullishOrEmpty, isNullish } from '@/shared/lang'",
      "",
      "export async function GET(request: NextRequest): Promise<NextResponse<XXXReadModel | null>> {",
      "  const session = await getSession()",
      "  if (isNullish(session)) {",
      "    return NextResponse.json(null, { status: 403 })",
      "  }",
      "  const search = request.nextUrl.searchParams.get('XXX')",
      "  if (isNullishOrEmpty(search)) {",
      "    return NextResponse.json(null, { status: 400 })",
      "  }",
      "  const query = new XXX(new PrismaXXXLoader())",
      "  const readModel = await query.handle({",
      "    // Ajouter les paramètres",
      "  })",
      "  return NextResponse.json(readModel)",
      "}",
    ],
  },
  "command": {
    "prefix": "_command",
    "scope": "typescript",
    "description": "Template d'un command handler (use case)",
    "body": [
      "import { CommandHandler, ResultAsync } from '../CommandHandler'",
      "import { GetUtilisateurRepository } from './shared/UtilisateurRepository'",
      "",
      "export class $TM_FILENAME_BASE implements CommandHandler<Command> {",
      "  readonly #utilisateurRepository: UtilisateurRepository",
      "  // Ajouter les autres repository",
      "",
      "  constructor(",
      "    utilisateurRepository: UtilisateurRepository",
      "    // Ajouter les autres repository",
      "  ) {",
      "    this.#utilisateurRepository = utilisateurRepository",
      "  }",
      "",
      "  async handle(command: Command): ResultAsync<Failure> {",
      "    const gestionnaire = await this.#utilisateurRepository.get(command.uidGestionnaire)",
      "",
      "    // Utiliser les autres repository, ajouter les règles métier et l'écriture en base de données",
      "",
      "    return 'OK'",
      "  }",
      "}",
      "",
      "type Failure =",
      "  // Ajouter les autres failures sous forme de string",
      "  | XXXFailure",
      "",
      "type Command = Readonly<{",
      "  uidXXX: string",
      "}>",
      "",
      "type UtilisateurRepository = GetUtilisateurRepository",
      "",
      "// Ajouter les autres types de repository",
      "",
    ],
  },
  "query": {
    "prefix": "_query",
    "scope": "typescript",
    "description": "Template d'un query handler (use case)",
    "body": [
      "import { QueryHandler } from '../QueryHandler'",
      "",
      "// S'il y en a besoin",
      "export class $TM_FILENAME_BASE implements QueryHandler<Query, XXXReadModel> {",
      "  readonly #loader: XXXLoader",
      "",
      "  constructor(loader: XXXLoader) {",
      "    this.#loader = loader",
      "  }",
      "",
      "  async handle(query: Query): Promise<XXXReadModel> {",
      "    return this.#loader.get(query.XXX)",
      "  }",
      "}",
      "",
      "export interface XXXLoader {",
      "  get(): Promise<XXXReadModel>",
      "}",
      "",
      "export type XXXReadModel = Readonly<{",
      "  // à complèter",
      "}>",
      "",
      "type Query = Readonly<{",
      "  // à complèter",
      "}>",
      "",
    ],
  },
  "server action": {
    "prefix": "_serverAction",
    "scope": "typescript",
    "description": "Template d'une server action (controller)",
    "body": [
      "'use server'",
      "",
      "import { revalidatePath } from 'next/cache'",
      "import { z } from 'zod'",
      "",
      "import prisma from '../../../../prisma/prismaClient'",
      "import { getSessionSub } from '@/gateways/NextAuthAuthentificationGateway'",
      "import { PrismaUtilisateurRepository } from '@/gateways/PrismaUtilisateurRepository'",
      "import { ResultAsync } from '@/use-cases/CommandHandler'",
      "",
      "export async function $TM_FILENAME_BASE(actionParams: ActionParams): ResultAsync<ReadonlyArray<string>> {",
      "  const validationResult = validator.safeParse(actionParams)",
      "",
      "  if (validationResult.error) {",
      "    return validationResult.error.issues.map(({ message }) => message)",
      "  }",
      "",
      "  const result = await new XXXUnMembre(",
      "    new PrismaUtilisateurRepository(prisma.utilisateurRecord)",
      "    // Ajouter les autres repository",
      "  ).handle({",
      "    uidGestionnaire: await getSessionSub(),",
      "    // Ajouter les autres paramètres",
      "  })",
      "",
      "  revalidatePath(validationResult.data.path)",
      "",
      "  return [result]",
      "}",
      "",
      "type ActionParams = Readonly<{",
      "  path: string",
      "}>",
      "",
      "const validator = z.object({",
      "  path: z.string().min(1, { message: 'Le chemin doit être renseigné' }),",
      "})",
      "",
    ],
  },
  "readonly type": {
    "prefix": "_readonlyType",
    "description": "Tout doit être immuable pour éviter de potentiel bug",
    "body": ["type ${1:Nom_du_type} = Readonly<{", "  // Ajouter les clés", "}>"],
  },
  "describe": {
    "prefix": "_describe",
    "description": "describe",
    "body": [
      "describe('$1', () => {",
      "  it('$2', () => {",
      "    // GIVEN",
      "",
      "    // WHEN",
      "",
      "    // THEN",
      "    expect(true).toBeFalsy()",
      "  })",
      "})",
      "",
    ],
  },
  "it": {
    "prefix": "_it",
    "description": "it",
    "body": [
      "it('$1', () => {",
      "  // GIVEN",
      "",
      "  // WHEN",
      "",
      "  // THEN",
      "  expect(true).toBeFalsy()",
      "})",
      "",
    ],
  },
}
