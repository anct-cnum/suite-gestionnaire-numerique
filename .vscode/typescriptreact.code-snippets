{
  "component": {
    "prefix": "_component",
    "scope": "typescriptreact",
    "description": "Template d'un composant",
    "body": [
      "import { ReactElement } from 'react'",
      "",
      "export default function $TM_FILENAME_BASE({ viewModel }: Props): ReactElement {",
      "  return (",
      "    <>",
      "      { /* Insérer du HTML */ }",
      "    </>",
      "  )",
      "}",
      "",
      "type Props = Readonly<{",
      "  viewModel: XXXViewModel",
      "}>",
      "",
    ],
  },
  "drawer écriture": {
    "prefix": "_drawerEcriture",
    "scope": "typescriptreact",
    "description": "Template d'un drawer d'écriture",
    "body": [
      "'use client'",
      "",
      "import { FormEvent, ReactElement, useContext, useId, useState } from 'react'",
      "",
      "import { clientContext } from '../shared/ClientContext'",
      "import Drawer from '../shared/Drawer/Drawer'",
      "import DrawerTitle from '../shared/DrawerTitle/DrawerTitle'",
      "import Icon from '../shared/Icon/Icon'",
      "import { Notification } from '../shared/Notification/Notification'",
      "import SubmitButton from '../shared/SubmitButton/SubmitButton'",
      "",
      "export default function $TM_FILENAME_BASE({ }: Props): ReactElement {",
      "  const { ajouterOuModifierXXXAction, pathname } = useContext(clientContext)",
      "  const [isDisabled, setIsDisabled] = useState(false)",
      "  // Stryker disable next-line BooleanLiteral",
      "  const [isDrawerOpen, setIsDrawerOpen] = useState(false)",
      "  const drawerId = 'drawerXXXId'",
      "  const labelId = useId()",
      "",
      "  return (",
      "    <>",
      "      <button",
      "        aria-controls={drawerId}",
      "        className='fr-btn fr-btn--secondary'",
      "        data-fr-opened='false'",
      "        onClick={() => {",
      "          setIsDrawerOpen(true)",
      "        }}",
      "        type='button'",
      "      >",
      "        XXX",
      "      </button>",
      "      <Drawer",
      "        boutonFermeture='Fermer le XXX'",
      "        closeDrawer={() => {",
      "          setIsDrawerOpen(false)",
      "        }}",
      "        id={drawerId}",
      "        // Stryker disable next-line BooleanLiteral",
      "        isFixedWidth={false}",
      "        isOpen={isDrawerOpen}",
      "        labelId={labelId}",
      "      >",
      "        <XXX",
      "          closeDrawer={() => {",
      "            setIsDrawerOpen(false)",
      "          }}",
      "          labelId={labelId}",
      "        >",
      "          <DrawerTitle id={labelId}>",
      "            <Icon icon='community-line' />",
      "            <br />",
      "            XXX",
      "          </DrawerTitle>",
      "          <form",
      "            aria-label='XXX'",
      "            method='dialog'",
      "            onSubmit={ajouterOuModifierXXX}",
      "          >",
      "            // Ajouter le reste du formulaire",
      "            <div className='fr-btns-group'>",
      "              <SubmitButton",
      "                ariaControls={drawerId}",
      "                isDisabled={isDisabled}",
      "              >",
      "                {isDisabled ? 'Ajout en cours...' : 'Ajouter'}",
      "              </SubmitButton>",
      "            </div>",
      "          </form>",
      "        </XXX>",
      "      </Drawer>",
      "    </>",
      "  )",
      "",
      "  async function ajouterOuModifierXXX(event: FormEvent<HTMLFormElement>): Promise<void> {",
      "    event.preventDefault()",
      "",
      "    setIsDisabled(true)",
      "    const form = new FormData(event.currentTarget)",
      "    const [XXX, XXX] = form.values() as FormDataIterator<string>",
      "    const messages = await ajouterOuModifierXXXAction({",
      "      path: pathname,",
      "      XXX,",
      "      XXX,",
      "    })",
      "    if (messages.includes('OK')) {",
      "      Notification('success', { description: 'ajoutée|modifiée', title: 'XXX ' })",
      "    } else {",
      "      Notification('error', { description: (messages as ReadonlyArray<string>).join(', '), title: 'Erreur : ' })",
      "    }",
      "    setIsDrawerOpen(false)",
      "    // S'il faut réinitialiser le formulaire",
      "    // (event.target as HTMLFormElement).reset()",
      "    setIsDisabled(false)",
      "  }",
      "}",
      "",
      "type Props = Readonly<{",
      "}>",
      "",
    ],
  },
  "drawer lecture": {
    "prefix": "_drawerLecture",
    "scope": "typescriptreact",
    "description": "Template d'un drawer de lecture",
    "body": [
      "'use client'",
      "",
      "import { ReactElement, useId, useState } from 'react'",
      "",
      "import Drawer from '../shared/Drawer/Drawer'",
      "import DrawerTitle from '../shared/DrawerTitle/DrawerTitle'",
      "import Icon from '../shared/Icon/Icon'",
      "",
      "export default function $TM_FILENAME_BASE({ }: Props): ReactElement {",
      "  // Stryker disable next-line BooleanLiteral",
      "  const [isDrawerOpen, setIsDrawerOpen] = useState(false)",
      "  const [XXX, setXXX] = useState<>()",
      "  const drawerId = 'drawerXXXId'",
      "  const labelId = useId()",
      "",
      "  return (",
      "    <>",
      "      <button",
      "        aria-controls={drawerId}",
      "        className='fr-btn fr-btn--secondary'",
      "        data-fr-opened='false'",
      "        onClick={() => {",
      "          setXXX(XXX)",
      "          setIsDrawerOpen(true)",
      "        }}",
      "        type='button'",
      "      >",
      "        XXX",
      "      </button>",
      "      <Drawer",
      "        boutonFermeture='Fermer le XXX'",
      "        closeDrawer={() => {",
      "          setIsDrawerOpen(false)",
      "        }}",
      "        id={drawerId}",
      "        // Stryker disable next-line BooleanLiteral",
      "        isFixedWidth={false}",
      "        isOpen={isDrawerOpen}",
      "        labelId={labelId}",
      "      >",
      "        <XXX",
      "          closeDrawer={() => {",
      "            setIsDrawerOpen(false)",
      "          }}",
      "          labelId={labelId}",
      "        >",
      "          <DrawerTitle id={labelId}>",
      "            <Icon icon='community-line' />",
      "            <br />",
      "            XXX",
      "          </DrawerTitle>",
      "        </XXX>",
      "      </Drawer>",
      "    </>",
      "  )",
      "}",
      "",
      "type Props = Readonly<{",
      "}>",
      "",
    ],
  },
  "page": {
    "prefix": "_page",
    "scope": "typescriptreact",
    "description": "Template d'une page (controller)",
    "body": [
      "import { Metadata } from 'next'",
      "import { notFound } from 'next/navigation'",
      "import { ReactElement } from 'react'",
      "",
      "export const metadata: Metadata = {",
      "  title: 'XXX',",
      "}",
      "",
      "export default async function XXXController({ params, searchParams }: Props): Promise<ReactElement> {",
      "  const { codeDepartement } = await params",
      "  // const { codeDepartement } = await searchParams",
      "",
      "  if (!codeDepartement) {",
      "    notFound()",
      "  }",
      "",
      "  // const readModel = await new XXX(new PrismaXXXLoader())",
      "  //   .handle({ codeDepartement })",
      "  // const viewModel = XXXPresenter(readModel)",
      "",
      "  return (",
      "    // <XXX viewModel={viewModel} />",
      "  )",
      "}",
      "",
      "type Props = Readonly<{",
      "  params: Promise<Readonly<{",
      "    codeDepartement: string",
      "  }>>",
      "  searchParams: Promise<Partial<Readonly<{",
      "    codeDepartement: string",
      "  }>>>",
      "}>",
      "",
    ],
  },
  "role = heading": {
    "prefix": "_getByHeading",
    "scope": "typescriptreact",
    "description": "Tester un titre",
    "body": [
      "const titre = screen.getByRole('heading', { level: XXX, name: 'XXX' })",
      "expect(titre).toBeInTheDocument()",
    ],
  },
  "role = region": {
    "prefix": "_getBySection",
    "scope": "typescriptreact",
    "description": "Tester une section",
    "body": [
      "const sectionXXX = screen.getByRole('region', { name: 'XXX' })",
      "const enTeteXXX = within(sectionXXX).getByRole('banner')",
      "const titreXXX = within(enTeteXXX).getByRole('heading', { level: 2, name: 'XXX' })",
      "expect(titreXXX).toBeInTheDocument()",
      "const articleXXX = within(sectionXXX).getByRole('article', { name: 'XXX' })",
    ],
  },
  "role = navigation": {
    "prefix": "_getByNavigation",
    "scope": "typescriptreact",
    "description": "Tester une navigation",
    "body": [
      "const navigation = screen.getByRole('navigation', { name: 'XXX' })",
      "const menu = within(navigation).getByRole('list')",
      "const menuItems = within(menu).getAllByRole('listitem')",
      "expect(menuItems).toHaveLength(XXX)",
      "const XXX = within(menuItems[0]).getByRole('link', { name: 'XXX' })",
      "expect(XXX).toHaveAttribute('href', 'XXX')",
      "const XXX = within(menuItems[1]).getByRole('link', { name: 'XXX' })",
      "expect(XXX).toHaveAttribute('href', 'XXX')",
    ],
  },
  "role = list": {
    "prefix": "_getByList",
    "scope": "typescriptreact",
    "description": "Tester une liste",
    "body": [
      "const menu = screen.getByRole('list')",
      "const menuItems = within(menu).getAllByRole('listitem')",
      "expect(menuItems).toHaveLength(XXX)",
      "expect(menuItems[0].textContent).toBe('XXX')",
      "expect(menuItems[1].textContent).toBe('XXX')",
    ],
  },
  "role = dialog": {
    "prefix": "_getByDialog",
    "scope": "typescriptreact",
    "description": "Tester une boîte de dialogue",
    "body": [
      "const drawer = screen.getByRole('dialog', { hidden: false, name: 'XXX' })",
      "expect(drawer).toHaveAttribute('id', 'drawerXXXId')",
      "const titre = within(drawer).getByRole('heading', { level: 1, name: 'XXX' })",
      "expect(titre).toBeInTheDocument()",
    ],
  },
  "role = internal link": {
    "prefix": "_getByLink",
    "scope": "typescriptreact",
    "description": "Tester un lien interne",
    "body": [
      "const XXX = screen.getByRole('link', { name: 'XXX' })",
      "// Si le label n'est pas assez explicite",
      "// const XXX = screen.getByRole('link', { description: 'XXX', name: 'XXX' })",
      "expect(XXX).toHaveAttribute('href', 'XXX')",
    ],
  },
  "role = external link": {
    "prefix": "_getByExternalLink",
    "scope": "typescriptreact",
    "description": "Tester un lien externe",
    "body": [
      "const XXX = screen.getByRole('link', { name: 'XXX' })",
      "expect(XXX).toHaveAttribute('href', 'XXX')",
      "expect(XXX).toOpenInNewTab('XXX')",
    ],
  },
  "role = table": {
    "prefix": "_getByTable",
    "scope": "typescriptreact",
    "description": "Tester un tableau",
    "body": [
      "const table = screen.getByRole('table', { name: 'XXX' })",
      "const [head, body] = within(table).getAllByRole('rowgroup')",
      "const rowHead = within(head).getByRole('row')",
      "const columnsHead = within(rowHead).getAllByRole('columnheader')",
      "expect(columnsHead).toHaveLength(XXX)",
      "expect(columnsHead[0].textContent)).toBe(XXX)",
      "expect(columnsHead[0]).toHaveAttribute('scope', 'col')",
      "expect(columnsHead[1].textContent)).toBe(XXX)",
      "expect(columnsHead[1]).toHaveAttribute('scope', 'col')",
      "const rowsBody = within(body).getAllByRole('row')",
      "const columns1Body = within(rowsBody[0]).getAllByRole('cell')",
      "expect(columns1Body).toHaveLength(XXX)",
      "expect(columns1Body[0].textContent).toBe(XXX)",
      "expect(columns1Body[1].textContent).toBe(XXX)",
      "const columns2Body = within(rowsBody[1]).getAllByRole('cell')",
      "expect(columns2Body).toHaveLength(XXX)",
      "expect(columns2Body[0].textContent).toBe(XXX)",
      "expect(columns2Body[1].textContent).toBe(XXX)",
    ],
  },
  "role = form": {
    "prefix": "_getByForm",
    "scope": "typescriptreact",
    "description": "Tester un formulaire",
    "body": [
      "const formulaire = within(drawer).getByRole('form', { name: 'XXX' })",
      "// S'il est dans un drawer",
      "// expect(formulaire).toHaveAttribute('method', 'dialog')",
    ],
  },
  "role = group": {
    "prefix": "_getByFieldset",
    "scope": "typescriptreact",
    "description": "Tester un fieldset",
    "body": ["const fieldset = within(formulaire).getByRole('group', { name: 'XXX' })"],
  },
  "role = combobox": {
    "prefix": "_getBySelect",
    "scope": "typescriptreact",
    "description": "Tester un select/option",
    "body": [
      "const XXX = within(formulaire).getByRole('combobox', { name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "const XXX = within(XXX).getByRole('option', { name: 'XXX', selected: true })",
      "expect(XXX).toBeInTheDocument()",
      "// Pas besoin de tester le name ni la value car cela est fait à travers la server action",
    ],
  },
  "role = number": {
    "prefix": "_getByNumber",
    "scope": "typescriptreact",
    "description": "Tester un champ numérique (il n'a pas de role)",
    "body": [
      "const XXX = within(formulaire).getByRole('spinbutton', { name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "expect(XXX).toHaveAttribute('type', 'number')",
      "expect(XXX).toHaveAttribute('min', 'XXX')",
      "// expect(XXX).toHaveAttribute('placeholder', 'XXX')",
      "expect(XXX).toHaveValue('XXX')",
    ],
  },
  "role = textbox": {
    "prefix": "_getByTextbox",
    "scope": "typescriptreact",
    "description": "Tester un champ texte",
    "body": [
      "const XXX = within(formulaire).getByRole('textbox', { name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "expect(XXX).toHaveAttribute('type', 'text')",
      "// expect(XXX).toHaveAttribute('placeholder', 'XXX')",
      "expect(XXX).toHaveValue('XXX')",
    ],
  },
  "role = textarea": {
    "prefix": "_getByTextarea",
    "scope": "typescriptreact",
    "description": "Tester un textarea",
    "body": [
      "const XXX = within(formulaire).getByRole('textbox', { name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "expect(XXX).toHaveAttribute('maxLength', 'XXX')",
      "// expect(XXX).toHaveAttribute('placeholder', 'XXX')",
      "expect(XXX).toHaveValue('XXX')",
    ],
  },
  "role = richtexteditor": {
    "prefix": "_getByRichTextEditor",
    "scope": "typescriptreact",
    "description": "Tester un éditeur de texte enrichi",
    "body": [
      "const editeurDeTextEnrichi = within(formulaire).getByRole('textarea', { name: 'XXX' })",
      "expect(editeurDeTextEnrichi).toBeInTheDocument()",
    ],
  },
  "role = radio": {
    "prefix": "_getByRadio",
    "scope": "typescriptreact",
    "description": "Tester un bouton radio",
    "body": [
      "const XXX = within(formulaire).getByRole('radio', { checked: true, name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "// Pas besoin de tester le name ni la value car cela est fait à travers la server action",
    ],
  },
  "role = checkbox": {
    "prefix": "_getByCheckbox",
    "scope": "typescriptreact",
    "description": "Tester une case à cocher",
    "body": [
      "const XXX = within(formulaire).getByRole('checkbox', { checked: false, name: 'XXX' })",
      "expect(XXX).toBeRequired() // ou .not",
      "// Pas besoin de tester le name ni la value car cela est fait à travers la server action",
    ],
  },
  "role = button button": {
    "prefix": "_getByButton",
    "scope": "typescriptreact",
    "description": "Tester un bouton",
    "body": [
      "const XXX = screen.getByRole('button', { name: 'XXX' })",
      "// Si le label n'est pas assez explicite",
      "// const XXX = screen.getByRole('button', { description: 'XXX', name: 'XXX' })",
      "expect(XXX).toHaveAttribute('type', 'button')",
    ],
  },
  "role = submit button": {
    "prefix": "_getBySubmitButton",
    "scope": "typescriptreact",
    "description": "Tester un bouton de type submit",
    "body": [
      "const XXX = within(formulaire).getByRole('button', { name: 'XXX' })",
      "expect(XXX).toHaveAttribute('type', 'submit')",
      "expect(XXX).toHaveAttribute('aria-controls', 'drawerXXXId')",
      "// L'un ou l'autre",
      "expect(XXX).toBeEnabled()",
      "expect(XXX).toBeDisabled()",
    ],
  },
  "input de type file": {
    "prefix": "_getByFile",
    "scope": "typescriptreact",
    "description": "Tester un champ d'upload (il n'a pas de role)",
    "body": [
      "const XXX = within(formulaire).getByLabelText('XXX')",
      "expect(XXX).toBeRequired() // ou .not",
      "expect(XXX).toHaveAttribute('type', 'file')",
    ],
  },
  "input de type date": {
    "prefix": "_getByDate",
    "scope": "typescriptreact",
    "description": "Tester un champ de date (il n'a pas de role)",
    "body": [
      "const XXX = within(formulaire).getByLabelText('XXX')",
      "expect(XXX).toBeRequired() // ou .not",
      "expect(XXX).toHaveAttribute('type', 'date')",
      "// expect(XXX).toHaveAttribute('placeholder', 'XXX')",
      "expect(XXX).toHaveValue('XXX')",
    ],
  },
  "rechercher par un texte": {
    "prefix": "_getByText",
    "scope": "typescriptreact",
    "description": "Tester une chaîne de caractères",
    "body": [
      "const XXX = screen.getByText('XXX', { selector: 'p' })",
      "expect(XXX).toBeInTheDocument()",
    ],
  },
  "presser le bouton": {
    "prefix": "_presserLeBouton",
    "scope": "typescriptreact",
    "description": "Presser le bouton",
    "body": [
      "const button = screen.getByRole('button', { description: 'XXX', name: 'XXX' })",
      "fireEvent.click(button)",
      "return button",
    ],
  },
  "cocher la case": {
    "prefix": "_cocherLaCase",
    "scope": "typescriptreact",
    "description": "Cocher la case",
    "body": ["fireEvent.click(screen.getByRole('checkbox', { name: 'XXX' }))"],
  },
  "presser le bouton radio": {
    "prefix": "_presserLeBoutonRadio",
    "scope": "typescriptreact",
    "description": "Presser le bouton radio",
    "body": ["fireEvent.click(screen.getByRole('radio', { name: 'XXX' }))"],
  },
  "saisir le texte": {
    "prefix": "_saisirLeTexte",
    "scope": "typescriptreact",
    "description": "Saisir le texte",
    "body": [
      "const input = screen.getByLabelText('XXX')",
      "fireEvent.change(input, { target: { value: 'XXX' } })",
      "return input",
    ],
  },
  "sélectionner l'élement": {
    "prefix": "_selectionnerLElement",
    "scope": "typescriptreact",
    "description": "Sélectionner l'élement",
    "body": ["await select('XXX', 'XXX')"],
  },
  "doublure de conceal": {
    "prefix": "_stubbedConceal",
    "scope": "typescriptreact",
    "description": "La doublure de la fonction DSFR conceal pour fermer le drawer",
    "body": ["vi.stubGlobal('dsfr', stubbedConceal())"],
  },
  "it fermer drawer": {
    "prefix": "_itFermerDrawer",
    "scope": "typescriptreact",
    "description": "Fermer le drawer",
    "body": [
      "it('puis que je clique sur fermer, alors le drawer se ferme', () => {",
      "  // GIVEN",
      "  afficherXXX()",
      "",
      "  // WHEN",
      "  jOuvreXXX()",
      "  const drawer = screen.queryByRole('dialog', { hidden: false, name: 'XXX' })",
      "  const fermer = jeFermeXXX('Fermer le ...')",
      "",
      "  // THEN",
      "  expect(fermer).toHaveAttribute('aria-controls', 'drawerXXXId')",
      "  expect(drawer).not.toBeVisible()",
      "})",
    ],
  },
  "it server action est OK": {
    "prefix": "_itServerActionOK",
    "scope": "typescriptreact",
    "description": "Tester une server action qui est en succès",
    "body": [
      "it('puis que je remplis correctement le formulaire, alors le drawer se ferme, une notification s’affiche, la XXX est mise à jour et le formulaire est réinitialisé', async () => {",
      "  // GIVEN",
      "  const ajouterXXXAction = vi.fn(async () => Promise.resolve(['OK']))",
      "  afficherXXX({ ajouterXXXAction, pathname: '/XXX' })",
      "",
      "  // WHEN",
      "  jOuvreXXX()",
      "  const drawer = screen.getByRole('dialog', { hidden: false, name: 'XXX' })",
      "  const nom = jeTapeXXX('XXX')",
      "  jeSelectionneXXX('XXX')",
      "  const enregistrer = jEnregistreXXX()",
      "",
      "  // THEN",
      "  expect(enregistrer).toHaveAccessibleName('Ajout en cours...')",
      "  expect(enregistrer).toBeDisabled()",
      "  // Tester que les champs sont vides",
      "  // const XXX = await screen.findByRole('radio', { checked: false, hidden: true, name: 'XXX' })",
      "  // expect(XXX).toBeInTheDocument()",
      "  // expect(nom).toHaveValue('')",
      "  expect(drawer).not.toBeVisible()",
      "  expect(ajouterXXXAction).toHaveBeenCalledWith({",
      "    path: '/XXX',",
      "    // Les autres paramètres",
      "  })",
      "  const notification = await screen.findByRole('alert')",
      "  expect(notification.textContent).toBe('XXX')",
      "  expect(enregistrer).toHaveAccessibleName('Enregistrer')",
      "  expect(enregistrer).toBeEnabled()",
      "})",
    ],
  },
  "it server action est NOK": {
    "prefix": "_itServerActionNOK",
    "scope": "typescriptreact",
    "description": "Tester une server action qui est en erreur",
    "body": [
      "it('puis que je remplis correctement le formulaire mais qu’une erreur intervient, alors une notification s’affiche', async () => {",
      "  // GIVEN",
      "  const ajouterXXXAction = vi.fn(async () => Promise.resolve(['Le format est incorrect', 'autre erreur']))",
      "  afficherXXX({ ajouterXXXAction })",
      "",
      "  // WHEN",
      "  jOuvreXXX()",
      "  jeTapeXXX('XXX')",
      "  jeSelectionneXXX('XXX')",
      "  jEnregistreXXX()",
      "",
      "  // THEN",
      "  const notification = await screen.findByRole('alert')",
      "  expect(notification.textContent).toBe('Erreur : Le format est incorrect, autre erreur')",
      "})",
    ],
  },
}
